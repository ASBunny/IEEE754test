/*Подключаем библиотеки для работы с программой*/
#include "pch.h"
#include <iostream>
#include <fstream>
#include <iostream>
#include <sstream>
#include <bitset>
#include <fstream>
#include <iostream>
#include <cstdlib>
#include <string>
using namespace std;
//Функция записи числа в бинарный файл inBin(ваше число, "называние файла")
void inBin(float a,string s){

	ofstream out(s, ios::binary); //создаём поток в бинарный файл
	out.write((char*)&a, sizeof(a)); //записываем в бинарный файл
	out.close(); // закрываем поток(чтобы небыло мусора и всё незабагалось)
}
//Функция чтения  бинарного файла с выводом на консоль числа в битовом представлении outBin("название файла")
string outBin(string s){
	ifstream ifs(s, ios::binary);// содали поток из бинарного файла
	ostringstream oss;  //создаём вспомогательный объект класса ostringstream для преобразования данных из потока в строковый вид
	string str, str1; 
	unsigned char n; //переменная для посимвольного чтения(присваивается каждый новый символ в цикле)
	str1 = "";
	while (true)  
	{
		ifs.read((char *)&n, 1);//посимвольно считываем поток  (1 байт = 8 бит = 1символ)
		if (ifs.eof())    //пока не достигнут конец - читаем, иначе ливаем с цикла
			break;
		oss << bitset<8>(n);  //извлекаем первый байт, тоесть первые 8 бит - с помощью контейнера bitset для хранения битов
		str = oss.str();  //преобразуем в строковый вид наши биты  с помощью метода str()
		str1 = str + str1; //строим последовательность битов в строку(конкатенация строк)
		oss.str(""); //обнуляем наш потоковый объект для записи следующих 8 бит
	}
	ifs.close(); 
	return str1;
}
void main()
{
	setlocale(LC_ALL, "rus");
	int b[8];
	double d;
	double E = 0.0;
	double M = 0.0;
	cout << "Ввeдите вещественное число: ";
	cin >> d;
	cout << endl;
	cout << "Получено число: " << d << endl;
	inBin(d,"out.dat"); // запись в файл
	cout << "Число " << d << " записано в бинарный файл" << endl;
	string str1= outBin("out.dat");//чтение из файла 
	cout << endl;
	cout << "32 битный формат числа "<<d<< " согласно стандарту IEEE754: ";
	cout << str1[0] << " ";
	//Вывод на экран 32 битное представление вещественного числа
	for (int i = 1; i < 9; i++) {
		cout << str1[i];
	}
	cout << " ";
	for (int i = 9; i < 23; i++) {
		cout << str1[i];
	}
	//Вычисление  экспоненты мантиссы (уже в десятичной форме)
	for (int i = 1; i < 9; i++) {
		 E += ((str1[i] - '0')*pow(2, 8 - i)); //(str1[i] - '0') -> преобразование char в int
	}
	for (int i = 9; i < 23; i++) {
		M +=  (str1[i] - '0')*pow(2, 23-(i-8)); //(str1[i] - '0') -> преобразование char в int	
	}
	int S = str1[0]-'0';//(str1[i] - '0') -> преобразование char в int	
	cout << endl;
	cout << "Бит знака S=" << S<<" => ";
	if (S == 0) cout << "число положительное" << endl;
	else cout << "число отрицательное" << endl;
	cout << "Экспонента E="<<E<<endl;
	cout << "Мантисса M=" << M << endl<<endl;
	cout << "Формула для получения десятичного числа из числа IEEE754 одинарной точности - " << endl;
	cout << "- десятичное число = (-1)^S * 2^(E-127) *(1+M/(2^23))" << endl<<endl;
	cout << "Восстановленное число из 32 битного формата IEEE754: "<<pow(-1,S)*pow(2,E-127)*(1+M/pow(2,23))<<endl;
}





